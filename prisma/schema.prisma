generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String               @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  email                  String?              @unique
  password               String?              @db.VarChar(60)
  name                   String?
  embedlyCustomerId      String?              @db.Char(36)
  country                String?              @db.VarChar(100)
  bvn                    String?              @db.VarChar(64)
  gender                 Gender               @default(Male)
  dob                    DateTime?            @db.Date
  phone                  String?              @unique @db.VarChar(20)
  emailVerified          Boolean              @default(false)
  occupation             String?              @db.VarChar(30)
  education              String?              @db.VarChar(30)
  religion               String?              @db.VarChar(30)
  maritalStatus          String?              @db.VarChar(20)
  pin                    String?
  status                 Status               @default(ACTIVE)
  isLocked               Boolean              @default(false)
  failedLoginAttempts    Int                  @default(0)
  lockUntil              DateTime?
  tierId                 String?              @db.Char(36)
  currentTier            String               @default("TIER_1")
  tier                   TierLimit?           @relation("UserTierLimit", fields: [tierId], references: [id])
  passwordResetTokenHash String?
  passwordResetExpires   DateTime?
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @default(now()) @updatedAt @db.Timestamp(6)
  role                   UserRole             @default(USER)
  agent                  Agent?               @relation("UserAgent")
  addressId              String?              @db.Char(36)
  address                Address?             @relation("AddressUser", fields: [addressId], references: [id])
  verificationIntents    VerificationIntent[] @relation("UserVerificationIntent")
  auditLogs              AuditLog[]           @relation("UserLogs")
  refreshTokens          RefreshToken[]       @relation("UserRefreshToken")
  banks                  Bank[]               @relation("BankUser")
  merchant               Merchant?            @relation("UserMerchant")
  merchantId             String?              @db.Char(36)
  instution              Intitution?          @relation("UserIntitution", fields: [intitutionId], references: [id])
  instutionId            String?              @db.Char(36)
  verifications          Verification[]       @relation("VerificationUser")
  intitutionId           String?              @db.Char(36)
  wallets                Wallet[]             @relation("WalletUser")
  Airtime                Airtime[]
}

model Agent {
  id          String     @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  userId      String     @unique @db.VarChar(36)
  user        User       @relation("UserAgent", fields: [userId], references: [id])
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @default(now()) @updatedAt @db.Timestamp(6)
  nextOfKinId String?    @unique @db.Char(36)
  nextOfKin   NextOfKin? @relation("NextOfKinAgent", fields: [nextOfKinId], references: [id])
}

model Merchant {
  id         String     @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  userId     String     @unique @db.VarChar(36)
  user       User       @relation("UserMerchant", fields: [userId], references: [id])
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @default(now()) @updatedAt @db.Timestamp(6)
  businesses Business[] @relation("BusinessMerchant")
}

model Intitution {
  id        String     @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @default(now()) @updatedAt @db.Timestamp(6)
  users     User[]     @relation("UserIntitution")
  Business  Business[]
}

model NextOfKin {
  id           String  @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  name         String
  phone        String  @unique @db.VarChar(20)
  relationship String
  agents       Agent[] @relation("NextOfKinAgent")
}

model Address {
  id             String     @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  streetLine     String
  city           String?
  state          String?
  country        String?    @db.VarChar(100)
  office_address String?
  landmark       String?
  homeAddress    String?
  lga            String?
  updatedAt      DateTime   @default(now()) @updatedAt @db.Timestamp(6)
  createdAt      DateTime   @default(now())
  users          User[]     @relation("AddressUser")
  businesses     Business[] @relation("AddressBusiness")
}

model Business {
  id            String         @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  category      String
  name          String
  merchantId    String         @db.VarChar(36)
  merchant      Merchant       @relation("BusinessMerchant", fields: [merchantId], references: [id])
  contactPhone  String?
  contactEmail  String?
  addressId     String?        @db.Char(36)
  address       Address?       @relation("AddressBusiness", fields: [addressId], references: [id])
  banks         Bank[]         @relation("BankBusiness")
  verifications Verification[] @relation("VerificationBusiness")
  Intitution    Intitution?    @relation(fields: [intitutionId], references: [id])
  intitutionId  String?        @db.Char(36)
}

model RefreshToken {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  userId     String
  tokenHash  String   @unique
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  user       User     @relation("UserRefreshToken", fields: [userId], references: [id])
  deviceInfo String?
  updatedAt  DateTime @default(now()) @updatedAt @db.Timestamp(6)
}

model AuditLog {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  userId    String?
  action    String
  meta      Json?
  ip        String?
  createdAt DateTime @default(now())
  user      User?    @relation("UserLogs", fields: [userId], references: [id])
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamp(6)
}

model Verification {
  id          String                 @id @default(uuid())
  userId      String?                @db.Char(36)
  user        User?                  @relation("VerificationUser", fields: [userId], references: [id])
  businessId  String?                @db.Char(36)
  business    Business?              @relation("VerificationBusiness", fields: [businessId], references: [id])
  status      VerificationStatus     @default(PENDING) // overall status
  submittedAt DateTime               @default(now())
  verifiedAt  DateTime?
  documents   VerificationDocument[]
}

model VerificationDocument {
  id              String             @id @default(uuid())
  verificationId  String
  verification    Verification       @relation(fields: [verificationId], references: [id])
  type            DocumentType
  fileUrl         String
  status          VerificationStatus @default(PENDING)
  reviewedBy      String?            @db.Char(36)
  reviewNotes     String?
  rejectionReason String?
  submittedAt     DateTime           @default(now())
  verifiedAt      DateTime?
}

enum DocumentType {
  PASSPORT
  NATIONAL_ID
  DRIVER_LICENSE
  UTILITY_BILL
  VOTER_CARD
  CAC
  MEMART
  IDFRONT
  IDBACK
  AUTHORITY_LETTER
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model Bank {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  name          String
  accountName   String
  accountNumber Int
  type          String
  userId        String?   @db.Char(36)
  user          User?     @relation("BankUser", fields: [userId], references: [id])
  businessId    String?   @db.Char(36)
  business      Business? @relation("BankBusiness", fields: [businessId], references: [id])
}

model IdempotencyKey {
  key          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  requestHash  String
  responseBody Json?
  statusCode   Int?
  lockedAt     DateTime?
  updatedAt    DateTime  @default(now()) @updatedAt @db.Timestamp(6)
  createdAt    DateTime  @default(now())
}

model Airtime {
  id             String        @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  idempotencyKey String?       @unique
  userId         String        @db.Char(36)
  walletId       String        @db.Char(36)
  provider       String // "AKUUK"
  phoneNumber    String
  network        String // e.g., "MTN", "AIRTEL"
  amount         BigInt // in kobo
  currency       String        @default("NGN")
  status         AirtimeStatus @default(PENDING)
  error          String?
  reference      String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @default(now()) @updatedAt

  // relations
  ledgerEntryId String? @db.Char(36)
  ledgerEntry   Ledger? @relation(fields: [ledgerEntryId], references: [id])
  user          User    @relation(fields: [userId], references: [id])
  wallet        Wallet  @relation(fields: [walletId], references: [id])
}

model Fee {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  transactionId String   @db.Char(36)
  ledgerId      String?  @db.Char(36)
  provider      String?  @db.Char(36)
  type          FeeType  @default(INTERNAL)
  rate          Float
  amount        Float
  currency      String
  status        String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt
}

model Provider {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  provider  String   @unique
  balance   BigInt   @default(0)
  metadata  Json?
  total     Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  ledgers   Ledger[] @relation("ProviderLedger")
}

model VerificationIntent {
  id          String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  user        User                   @relation("UserVerificationIntent", fields: [userId], references: [id])
  userId      String                 @db.Char(36)
  type        VerificationIntentType
  refreshCode String                 @db.VarChar(100)
  expiresAt   DateTime               @default(dbgenerated("NOW() + interval '60 minutes'")) @db.Timestamp(6)
  createdAt   DateTime               @default(now()) @db.Timestamp(6)
  updatedAt   DateTime               @default(now()) @updatedAt @db.Timestamp(6)
}

model TierLimit {
  id        String   @id @default(uuid())
  tier      String   @unique
  dailyCap  BigInt
  createdAt DateTime @default(now())
  users     User[]   @relation("UserTierLimit")
}

model Wallet {
  id               String    @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  userId           String    @db.Char(36)
  walletId         String
  status           Status    @default(INACTIVE)
  currency         String    @default("NGN")
  bankName         String    @db.Char(20)
  bankCode         String    @db.Char(3)
  accountNumber    String    @db.Char(10)
  availableBalance BigInt    @default(0)
  ledgerBalance    BigInt    @default(0)
  reservedBalance  BigInt    @default(0) // funds reserved for pending transfers
  version          Int       @default(1) // optimistic version / CAS
  ledgerEntries    Ledger[]  @relation("WalletLedger")
  user             User?     @relation("WalletUser", fields: [userId], references: [id])
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @default(now()) @updatedAt
  Airtime          Airtime[]

  @@unique([walletId])
  @@index([userId])
}

model Transfer {
  id                   String         @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  idempotencyKey       String?        @unique
  fromWalletId         String?        @db.Char(36)
  fromProviderId       String?        @db.Char(36)
  toWalletId           String?        @db.Char(36)
  provider             String         @default("EMBEDLY")
  amount               BigInt
  shouldRefund         Boolean        @default(true)
  transactionReference String?
  currency             String         @default("NGN")
  status               TransferStatus @default(PENDING)
  initiatedBy          String? // userId who initiated
  reason               String?
  metadata             Json?
  completedAt          DateTime?
  type                 TransferType   @default(INTERNAL)
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @default(now()) @updatedAt
  ledgerEntries        Ledger[]       @relation("TransferLedger")

  @@index([fromWalletId])
  @@index([toWalletId])
  @@index([createdAt])
}

model Ledger {
  id           String        @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  walletId     String?       @db.Char(36)
  providerId   String?       @db.Char(36)
  transferId   String?       @db.Char(36)
  journalId    String?       @db.Char(36) // groups ledger rows for double-entry
  change       BigInt // negative for debit, positive for credit
  balanceAfter BigInt
  type         LedgerType
  metadata     Json?
  createdAt    DateTime      @default(now())
  journal      JournalEntry? @relation("JournalLedgers", fields: [journalId], references: [id])
  wallet       Wallet?       @relation("WalletLedger", fields: [walletId], references: [id])
  provider     Provider?     @relation("ProviderLedger", fields: [providerId], references: [id])
  transfer     Transfer?     @relation("TransferLedger", fields: [transferId], references: [id])
  airtimes     Airtime[]

  @@index([walletId])
  @@index([journalId])
  @@index([transferId])
}

model OutboxEvent {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  aggregateId String?
  topic       String
  payload     Json
  published   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  publishedAt DateTime?
}

model JournalEntry {
  /**
   * A JournalEntry represents a single double-entry transaction (one credit + one debit; or many-line journal)
   * Each Wallet Ledger row references its JournalEntry. This makes it easy to reconcile and to ensure double-entry invariants.
   */
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Char(36)
  reference   String? // external provider ref (eg Embedly reference)
  transferId  String?   @db.Char(36)
  description String?
  metadata    Json?
  createdAt   DateTime  @default(now())
  postedAt    DateTime?

  // child ledger rows (should normally be 2 for a simple transfer)
  ledgers Ledger[] @relation("JournalLedgers")

  @@index([transferId])
  @@index([reference])
}

enum Status {
  ACTIVE
  PENDING
  INACTIVE
}

enum TransferStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum LedgerType {
  TRANSFER_DEBIT
  TRANSFER_CREDIT
  FEE
  ADJUSTMENT
}

enum VerificationIntentType {
  EMAIL
  PHONE
}

enum Gender {
  Male
  Female
}

enum UserRole {
  USER
  AGENT
  INSTITUTION
  MERCHANT
}

enum TransferType {
  INTERNAL
  EXTERNAL
}

enum AirtimeStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum FeeType {
  INTERNAL
  DATA
  EXTERNAL
  AIRTIME
}
